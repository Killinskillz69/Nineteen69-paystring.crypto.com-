# Ethereum 白書

### 次世代 Smart contract と 分散型アプリケーション基盤

ナカモトサトシの論文により、2009年に開発された Bitcoin は通貨・貨幣における革新的な発明だと
謳われ、金兌換のような後ろ盾がなく、中央通貨管理局をもたないはじめての デジタル財産 の例です。( [intrinsic value](http://bitcoinmagazine.com/8640/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it/) ) しかし、その壮大な Bitcoin の実験における、より特筆すべき重要部は別の所にあります。
それは分散型大衆決定のツールとして、まさにその基礎をなす Blockchain の技術であり、急速に人々の注目を集めつつあります。

一般的に、
blockchain テクノロジーを引用している Bitcoin の代替アプリで、
blockchain 上の電子財産を実装したものとして:

* 一定取引量のある通貨や金融商品をあらわすもの ([ colored coins ](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit))
* 基礎となる物理デバイスの所有権 ([ smart property ](https://en.bitcoin.it/wiki/Smart_Property))
* ドメインのような投資対象外の財産 ([ Namecoin ](http://namecoin.org))  

があり、より複雑なアプリケーションとしては以下のものが挙げられます:

* (役人や銀行員に取って代わり)、コーディングであらゆるルールを実装し、個々の電子資産を管理するもの([ smart contracts ](http://szabo.best.vwh.net/smart_contracts_idea.html))
* 上記のスマートコントラクトを blockchain 上で実装したもの ([ DAO ](http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/))

Ethereum が提供しようとしているものは、
チューリング完全なプログラミング言語の完成品を blockchain に埋め込み提供することにあります。
この言語は、"contract" を生成するために使用され、
"contract" とはあらゆる 関数 をプログラムしたものです。
これにより、ユーザーは上記の全てのシステムを実装することが可能で、
われわれがまだ想像すらしていない多くの可能性が、
論理を秘めし数行のコードを書き上げるだけで実現できるようになります。


### 目次
* [Bitcoin への導入 と 既存の概念](#Bitcoin-への導入-と-既存の概念)
    * [歴史](#歴史)
    * [状態遷移システム としての Bitcoin](#状態遷移システム-としての-bitcoin)
    * [採掘](#採掘)
    * [マークル木](#マークル木)
    * [Blockchain を用いた代替アプリケーション](#blockchain-を用いた代替アプリケーション)
    * [スクリプト言語による記述](#スクリプト言語による記述)
* [Ethereum](#ethereum)
    * [Ethereum アカウント](#ethereum-アカウント)
    * [メッセージ と トランザクション](#メッセージ-と-トランザクション)
    * [Ethereum の 状態遷移関数](#ethereum-の-状態遷移関数)
    * [コード実行](#コード実行)
    * [Blockchain と 採掘](#blockchain-と-採掘)
* [アプリケーション](#アプリケーション)
    * [証明書発行のシステム](#証明書発行のシステム)
    * [金融ディリバティブ と 安定価格通貨](#金融ディリバティブ-と-安定価格通貨)
    * [Identity と Reputation のシステム](#identity-と-reputation-のシステム)
    * [分散型ファイルストレージ](#分散型ファイルストレージ)
    * [分散型自律組織](#分散型自律組織)
    * [その他のアプリケーション](#その他のアプリケーション)
* [雑録 と 関心事](#雑録-と-関心事)
    * [GHOST の修正実装](#ghost-の修正実装)
    * [手数料](#手数料)
    * [計算 と チューリング完全](#計算-と-チューリング完全)
    * [通貨 と 発行](#通貨-と-発行)
    * [マイニング集中](#マイニング集中)
    * [スケーラビリティ](#スケーラビリティ)
* [結論](#結論)
* [脚注 及び 参考文献](#脚注-及び-参考文献)

## Bitcoin への導入 と 既存の概念

### 歴史

上述の資産登録マシンのような代替アプリや、
分散型デジタル通貨の概念が現れ始めたのは、ここ数十年です。
80〜90年代にかけて、David Chaum の「ブラインディング署名 blinding signature」をよりどころとした
匿名のデジタル通貨プロトコルがたくさん開発され、高いプライバシーをもつ通貨を提供しましたが、
これらは中央集約型の媒体に依存していたため、広く注目を浴びるには至りませんでした。
1998年に発表された、Wei Daiによる [b-money](http://www.weidai.com/bmoney.txt) が、
現行の分散型のコンセンサスと同様のもので、計算問題を解くことによって
お金を創造するというアイデアを、はじめて導入した事例となります。
しかし、このプロポーザルの詳細は不十分であったため、実用的な分散型の大衆意思決定を実装することができませんでした。
2005年、Hal Finney が、暗号通貨のコンセプトをつくりあげるために、
ABCD Hashcash パズル<sup>[jp-1]</sup> と b-money からアイデアをしぼり作られたシステムである "[reusable proofs of work](http://www.finney.org/~hal/rpow/)" というコンセプトを発表しましたが、バックエンドに、信用のある計算機を使用しなければならなかったため、真に分散型とは呼べず、再び失敗しました。
2009年のナカモトサトシによる実用的な実装がはじめての分散型の通貨となりました。
これは、昔からあった「公開鍵暗号（所有権を管理) 」と
大衆意思決定アルゴリズムである「 "proof of work" (誰がコインを所有しているのか追跡)」
を結びあわせたものとなります。


proof of work の背景にある技術は宇宙史に名を刻むほどの飛躍的進歩でありました。
なぜなら proof of work は、同時に二つの難題を解決したのです。

* ひとつめは、単純明快で適切な影響力をもつ大衆意思決定のアルゴリズムの提供で、
ネットワーク上のノードはBitcoinの帳簿の「一般規則に従う状態更新」ができるようになりました。
* ふたつめは、大衆意思決定のプロセスへの自由参加を可能にするメカニズムの提供で、
誰が、コンセンサスに影響をもたらすのかということを決める政治的問題を解決したのです。

これは次のようにして、参加基準を定式化したということです。

1. ノードに対し、特定リストにおける唯一性の証明書の提出を要求し、
2. さらに「大衆意思決定のプロセスにおける単位ノードの重みは、ノードのもつ計算能力に応じて分配する」
という エコノミックバリア<sup>[jp-2]</sup> を採用する



### 状態遷移システム としての Bitcoin

![statetransition.png](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/statetransition.png)

技術的観点から見ると、（本来 Bitcoin は、状態を持たない、ただの関数の鎖に過ぎない純粋なものですが、）
 Bitcoin をはじめとした暗号通貨の帳簿は、全 bitcoin の所有状況をあらわす「状態」と、状態と取引(トランザクション、状態遷移関数のこと)から新たな状態を出力する「状態遷移関数」をもった、「状態遷移」のシステムとしてみることができます。
一般的銀行のシステムでは、たとえば「状態」はバランスシートにあたり、
「トランザクション」はAからBにXドル移動してくれ、というリクエストにあたり、
この状態遷移関数は、XドルだけAの口座の残高を減らし、Bの残高を増やします。
もし、Aの口座の残高がXドルに満たなかった場合には、
状態遷移関数はエラーを返します。
これを定式化し、

    APPLY(S,TX) -> S' or ERROR

この銀行システムは以上で定義され、以下はその適用例です。

    APPLY({ Alice: $50, Bob: $50 },"send $20 from Alice to Bob") = { Alice: $30, Bob: $70 }  

    APPLY({ Alice: $50, Bob: $50 },"send $70 from Alice to Bob") = ERROR


Bitcoin における「状態 state」とは、全コインの集合 であり、
技術的に説明いたしますと、
発行されているコインのうちで「UTXO（未使用の取引出力値）」の全集合 となり、各 UTXO には、それぞれ「残高」と「所有者」が記録されています。
「所有者」は、基本的に、暗号理論における公開鍵<sup>[1]</sup>である20バイト(160bit)のアドレスとなります。
「トランザクション」は、状態遷移関数であり、一以上の入力値 と 一以上の出力値 をとります。
各入力値は、「既存の UTXO への参照」と「所有者のアドレスと関連付けられた秘密鍵による暗号署名」 から構成され、
各出力値は、「新しく生成された UTXO」を保持しています。

状態遷移関数 `APPLY(S,TX) -> S'` を定義するプログラムの概略は以下となります。:

1. 各入力 `TX` に対して:
    * もし、参照先の UTXO が、状態 `S` に保持されていないならば、エラーを返す。
    * もし、提供された署名がその UTXO の所有者のものとマッチしなければ、エラーを返す。
2. もし、入力用の全 UTXO の価値の合計が、出力用の全 UTXO の価値の合計より小さければ、エラーを返します。
3. 入力用の全 UTXO を取り除き、出力用の全 UTXO を加えた新たな状態 `S` を返します。

ひとつめのステップにおける
前半部により、トランザクションの送信者が、存在しないコインを不正に送ることを防止し、
後半部により、トランザクションの送信者が、他人のコインを勝手に送ることを防止します。
ふたつめのステップによって、トータルバリューの保存（入力値の総計 が 出力値の総計 と等しい）が執行されます。
これを実用的な支払いに適用するための、プロトコルは以下のようになります。

アリスがボブに 11.7 BTC を送信したいとします。
まずはじめに、アリスは、利用可能な UTXO を自分の持っているものの中からかき集め、
少なくとも総計 11.7 BTC になるようにします。アリスの UTXO を集めてちょうど 11.7 BTC をつくることはできず、6+4+2=12 BTC がアリスの得る最小の値です。
そして彼女は、３つの入力値と２つの出力値をもつトランザクションをつくります。
ひとつめの出力値は 11.7 BTC でボブのアドレスが所有者として記録され、
ふたつめの出力値は 0.3 BTC の"お釣り"がアリス自身を所有者として記録されます。



### 採掘

![block_picture.jpg](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/block.png)

もし、アクセス対象として信用取引可能な 中央集約型 のサービスを使っているのであれば、
このシステムの実装は至極簡単なものであったでしょう。
単に上記のプログラムコードを記すのに、中央サーバーのハードディスクを使用し、「状態」を記録・維持すれば済む話であったでしょう。
しかし、わたしたちが Bitcoin を用いてやろうとしているのは、分散型通貨システムの構築です。
なので、トランザクションの順番をみんなが合意できることを確約するために、
状態遷移システム と 大衆意思決定のシステム をくっつけてやらなくてはなりません。
Bitcoin の分散型大衆決定プロセスでは、「ブロック」と呼ばれる「トランザクションを梱包したもの」を作り続けようとする、
ネットワーク上のノードが必要です。 
ネットワークは、だいたい10分毎にひとつの ブロック を生成するように設計されており、
各々のブロックは、

* 「タイムスタンプ」
* 「ノンス」
* 「直前のブロックへの参照値」
* 「（直前のブロック生成後から現在までに遂行された）トランザクションのリスト」

を保持します。（ ※ ノンス：ブロック生成時にインクリメントされ続ける個体識別ハッシュ値で、マイナーがブロックを掘り当てることを目標にして独自にインクリメントする。）
このブロックが時間発展することによって、
Bitcoin の帳簿を最新状態に更新し続ける、
永続的かつ恒久的成長をなす " blockchain " （ブロックの鎖）を生成します。


現パラダイム下において、ブロックが有効かどうかをチェックするアルゴリズムは以下となります：

1. そのブロックが参照する直前のブロックが存在し、それが有効であるかをチェックする。
2. そのブロックのタイムスタンプが直前のブロック<sup>[2]</sup> より大きく、かつ２時間後の未来におけるものまでそれにおけるものより小さいかを確認する。
3. そのブロック上での、proof of work が有効かチェックする。
4. 直前のブロックの終状態を `S[0]` とします。
5. `TX` を `n` 個のトランザクションからなる「リスト」だとします。`0...n-1` における、全ての `i` に対し、 `S[i+1] = APPLY(S[i],TX[i])` と順番に適用します。もし、一つでもエラーを返せば、exit し、false を返します。
6. true を返し、このブロックの最後の状態として `S[n]` を記録します。

基本的に
ブロック内の各トランザクションは、
トランザクション執行前の 過去の状態 をもとにして、有効な状態遷移を提供しなければなりません。
「状態」はいかなる点においても、ブロック内に記述されないことに注意してください。（ブロックは状態遷移関数をつなげ合わせた関数そのものであり、入力値 である「状態」については何も書かれていません）；
（このアルゴリズムは、「検証ノード」を説明する簡単な抽象例であり、
どのブロックの検証においても、開始状態から、全ブロックの全トランザクションを順番に適用することによって、
目的となるブロックの示す状態を計算すれば十分となります。）
さらに「採掘者 miner」がトランザクションをブロックに取り込む順番がとても重要だということに注意してください。
（もし、A、Bという二つのトランザクションがあって、BはAの生成した UTXO(未使用出力値) を使う場合において、
AのあとにBがきているブロックは有効ですが、そうでない場合は無効となってしまいます。）


他のシステムでは見受けられない仕様として、
上述のトランザクションリストは、（どのトランザクションがどこに取り入れられるか、あるいは取り入れられないなど、によって数多の選択肢が考えられますが、）ここで「有効なものを一つ選ぶための選定条件」が "proof of work" には必要となります。
厳密な定義は、
全てのブロックの double-SHA256 hash値（256bit の数値）が 
動的に変化するように設計された「目的値 target」より小さくなること、であり、
目的値は、これを執筆している当時では、約2<sup>187</sup>でした。
これは、ブロック生成を計算科学上 "難しく" する為であり、
その結果、Sybil Attack（ひとりでノードを多数生成し多数決的に攻撃する手法）による攻撃者が自身の好きなように 全 blockchain を改竄してしまうことを防止いたします。
SHA256（エスエイチエーにごろ）は、完全に予測不可能な擬似乱数関数として設計されており、
有効なブロックをつくる唯一の方法は、単に ノンス をインクリメントしてはその新しい hash値 が適合するかを確かめるという、試行錯誤を繰り返すしかありません。



現在における ~ 2<sup>187</sup>の「目的値」では、
ネットワークは ~ 2<sup>69</sup> 回の試行錯誤をしてやっとブロックを見つけることができます。
ふつう、目的値 は、ネットワーク上で2016ブロック生成される毎に再設定され、
ネットワーク上にあるノードによるブロックの発掘が平均して10分毎に生じるよう調整されます。
採掘者に競わせてこの計算をさせるための設定として、
ブロックを採掘したものは、どこからともなく湧いた自分への25BTCの報酬を、
トランザクションとして最後に付け加えます。
さらに、
全入力値が全出力値よりも大きいような全てのトランザクションにおける、
その差額は「取引手数料 transaction fee」として、採掘者のもとへ行く仕組みです。
ところで、これはBitcoinが発行される唯一のメカニズムとなります。
つまり、初期状態においては、Bitcoin は皆無であったわけです。



マイニングの目的をより深く理解するために、
悪意ある攻撃者のおこす事件によって何がおこるのかを見ていきましょう。
Bitcoin の基礎となる暗号理論はセキュリティの高いものと知られているので、
攻撃者の狙い目としては、直接、暗号理論で守られていない部分 : トランザクションの順序 となるでしょう。

攻撃者の戦略は簡単なものです:

1. ある商売人に 100 BTC をある商品の購入代金として送る (瞬間的な発送ができるデジタル商品が好まれます)
2. 商品の到着を待つ
3. 自分自身に 100 BTC を送る別のトランザクションを生成する
4. ネットワークが、後に作った方のトランザクションの順番が最初にくるようなブロックを、承認するように試みる

一度、ステップ 1 が履行されると
数分後に採掘者がトランザクションをブロックに含めます。
ブロック番号は 270000 とします。
一時間後、５個以上のブロックが、そのブロックの後ろに追加され、
この５つのブロックが、間接的にそのトランザクションを参照しているため、
トランザクションは「承認 confirming」されたということになります。
この時点で、
商売人は、支払いが確定したものとみなし、商品を発送します。
ここではデジタル商品を考え、商品がすぐに届くこととします。
さていま、攻撃者が、別のトランザクションを作成し、自分宛に 100BTC を送るものとします。
攻撃者が、もし単にそれを野に放っただけならば、
そのトランザクションは受理されないでしょう。
法の番人である採掘者は、`APPLY(S,TX)` を実行するとき、`TX` が、使用済みUTXO を使用しようとしていることに気づくでしょう。
なので代わりに、
攻撃者はブロックチェーンを分岐させ、
親として同じ 269999 番目のブロックを参照する 270000 番目の新しいバージョンのブロックを生成します。
ここでは、もとのブロックに含まれていたトランザクションは含まれず、新しいトランザクションが追加されていくこととなります。
ブロックのデータの中身が違うので、
攻撃者は proof of work をやり直す必要があります。
さらに、攻撃者の新しいブロック 270000 では、異なるハッシュ値を生成するので、
もとのブロックチェーン上のブロック 270001 ~ 270005 は、このブロックを参照しません。
このように、もとのブロックチェーンと攻撃者のチェーンは完全に分断されるのです。
このとき適用されるルールは次のようになります。
ブロックチェーンの分岐時は、
一番長いブロックチェーンが "信用" あるものとして選択されます。
なので、攻撃者が新しい 270000 のブロックチェーン上で採掘し続ける傍で、
このシステムの法の番人である採掘者達はもとの 270005 のブロックチェーンを採掘し続けることになります。
攻撃者が、自分のブロックチェーンを最長にするためには、
ネットワーク上の残りのすべてのノードの総和より、高い計算能力を誇る必要があり、
これを「51%攻撃」と呼びます。




### マークル木
  
![SPV in bitcoin](https://raw.githubusercontent.com/ethereum/www/master-postsale/src/extras/gh_wiki/spv_bitcoin.png)


_左　 : 　
分岐の正当性の証明には、少しのノードを与えてやるだけでよい_

_右　 : 　
どの部分にいかなる変化を付与しても、鎖の上方で必ず不一致を生む_



  

Bitcoin の重要なスケーラビリティ特性は「ブロックは多層データ構造で保管される」ということです。
ブロックの「ハッシュ値」とは実は、ブロックヘッダ（先頭部）のハッシュ値 に過ぎず、これは約 200 byte のデータであり、

* タイムスタンプ
* ノンス
* 直前のブロックの ハッシュ値 
* マークル木（ブロック内の全トランザクションを保持するデータ構造）の ルート（根の元となる部分）の ハッシュ値

を保持します。マークル木は、バイナリ木のひとつで、以下の三つから構成されます。

* 基礎データを保持する木構造の最下層の「葉（リーフノード）」の集合
* 二つの 子ノード のハッシュ値である「枝（中間ノード）」の集合 
* 唯一の「根（ルートノード）」（二つの子ノードのハッシュ値で "頂上" にくるもの）

マークル木は、ブロック中のデータをバラバラに運搬するためにつくられました。
ノードは、ひとつのソース（ネットワーク上の自身とは別のノード）からブロックヘッダだけを、
別のソースから、必要なトランザクションに関連する小さな部分木を、ダウンロードすることができ、それでもなお全データの整合性を保証できるのです。
これがうまく動作する所以は、ハッシュ値が上に伝播していくところ です。：
もし悪意のあるユーザーが偽物のトランザクションをマークル木の底のノードと取り替えようとすると、この変化はその親のノードを変化させ、繰り返し伝播することで最終的にルートの値を変化させます。
つまり、ブロックのハッシュ値が変化し、マークル木のプロトコルにより、結果として、全く別のブロックとして記録され、このブロックは十中八九 proof of work が無効となります。


マークル木のプロトコルは、言うまでもなく長期にわたるアプリケーションの維持のために必要です。
Bitcoin ネットワークにおける「完全ノード、フルノード」とは、「全ブロックの全トランザクションを保管・処理するノード」のことで、
2014年4月の時点で 15GB の容量をとり、ひと月あたり１GB以上の速さで増え続けています。
現在、これはデスクトップコンピュータ上で目視できますが、携帯電話では確認できません。
容量的な観点から、後々の未来、完全ノード に参加できるのは、ビジネスや趣味の範疇に限られてくるでしょう。
「SPV （簡素な支払検証）」として知られるプロトコルにより、「完全ノード」とは別タイプのノードが開発されました。
「軽量ノード、ライトノード」と呼ばれ、このノードは、ブロックヘッダをダウンロードし、ブロックヘッダで proof of work を検証し、そして自身に関係のある トランザクションの「枝、ブランチ」だけをダウンロードします。
軽量ノードは、セキュリティを強く保ったまま、トランザクション履歴や残高を、状態遷移関数により決定することができるというのに、
全ブロックチェーンの小さな部分木をダウンロードすればよい、というものなのです。



### Blockchain を用いた代替アプリケーション

基礎技術である blockchain の他コンセプトへの応用は、これもまた、長い歴史があります。
2005 年　Nick Szabo が "[secure property titles with owner authority（自己の権威によるセキュアな財産の獲得）](http://szabo.best.vwh.net/securetitle.html)" というコンセプトを発表しました。この論文は、複製データベースの技術の進歩により、いかにして
blockchain 基調のシステムが、土地所有の登記 の保管を可能にするのかを記述し、
「開拓 homesteading」「不法占有 adverse possesion」「ジョージの土地課税 Georgian land tax」といったコンセプトを含む枠組みを、苦労して築き上げました。
しかし、残念ながら、当時利用できる、効果的な複製データシステムがなかったため、プロトコルが実際に実装されることはありませでした。
とは言うものの、2009 年に Bitcoin の分散型コンセンサス が一度開発されてからは、急速に代替アプリが出現し始めました。


* **Namecoin** - 2010年に作られた [Namecoin](https://namecoin.org/) は「分散型名前登録データベース」と表現されます。
Tor や Bitcoin , BitMessage のような分散型プロトコルでは、個体識別に アカウント が必要で、そのため他人による干渉が可能ですが、
どのようにしても利用可能な識別子は、`1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy`のような擬似乱数となります。
できれば "ジョージ" のような名前をつけることができたらいいな、と考えるでしょう。
しかしながら、問題なのは "ジョージ" という名前を誰でも、同じプロセスをたどることで登録でき、"ジョージ"として振舞えるのです。
唯一の解決策は 「first-to-file パラダイム」を用いることです。
これは、最初（first）の登録者は登録（file）に成功し、二番目以降では失敗するというものです。
この問題は Bitcoin の大衆意思決定のプロトコルに完全に合致し、 Namecoin は一早くにこの考えを使って名前登録のシステムを実装し、見事に成功しました。

* **Colored coins** - [colored coins](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit) の目的は、Bitcoin の blockchain 上に「自身で作ったデジタル通貨」や、
通貨の重要な性質である少額使用の例としてユニットを採用した「デジタルトークン」を、構築できるプロトコルを提供することです。
colored coins のプロトコルでは、
特定の Bitcoin UTXO に「色」を設定することで、
新しい通貨を "発行" します。
プロトコルは、colered coins を生成するトランザクションの入力値に「色」が付いていれば、他の UTXO も同じ「色」であるものと再帰的に定義します。
（様々な「色」の入力が混じった場合は、特別なルールが適用されます。）
このことで、ユーザーは特別な色の UTXO 